<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Worker Stats</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #121212; /* Dark background */
            color: #E0E0E0; /* Light text */
        }
        .container {
            background-color: #1E1E1E; /* Slightly lighter dark for container */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); /* Adjusted shadow for dark */
        }
        h1, h2 {
            color: #FFFFFF; /* White headings */
            margin-bottom: 0.5em;
            border-bottom: 1px solid #3A3A3A; /* Subtle divider */
            padding-bottom: 0.3em;
        }
        h1 { font-size: 1.8em; }
        h2 { margin-top: 1.5em; font-size: 1.4em; }
        h3 { font-size: 1.1em; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Slightly wider items */
            gap: 20px;
            margin-top: 10px;
        }
        .stat-item {
            background-color: #2C2C2C; /* Darker cards */
            padding: 20px; /* More padding */
            border-radius: 6px; /* Softer radius */
            position: relative;
            border: 1px solid #3A3A3A;
        }
        .stat-item h3 {
            margin-top: 0;
            margin-bottom: 10px; /* More space below h3 */
            color: #F5F5F5; /* Brighter heading for cards */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-item p {
            font-size: 1.3em; /* Larger paragraph text */
            font-weight: bold;
            margin-bottom: 5px;
            color: #4CAF50; /* Accent color for stat values, e.g., Green */
        }
        #recent_chunks_list {
            list-style-type: none;
            padding-left: 0;
            max-height: 350px; /* Increased height */
            overflow-y: auto;
            border: 1px solid #3A3A3A;
            border-radius: 4px;
            padding: 10px;
        }
        #recent_chunks_list li {
            background-color: #252525; /* Slightly different background for list items */
            margin-bottom: 10px;
            padding: 12px;
            border-radius: 4px;
            font-size: 0.9em;
            border-left: 3px solid #4CAF50; /* Accent border */
        }
        #recent_chunks_list li strong { color: #BDBDBD; } /* Lighter strong tags */
        #recent_chunks_list li small { color: #9E9E9E; } /* Lighter small tags */
        
        .info-icon-container {
            display: inline-block;
            position: relative;
            cursor: help;
        }
        .info-icon {
            font-size: 0.8em;
            color: #A0A0A0; /* Muted grey for icon */
            border: 1px solid #555555;
            border-radius: 50%;
            padding: 1px 5px; /* Adjusted padding */
            margin-left: 8px;
        }
        .tooltip-text {
            visibility: hidden;
            width: 240px; /* Wider tooltip */
            background-color: #424242; /* Darker tooltip background */
            color: #FFFFFF;
            text-align: left; /* Left align text */
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 10;
            bottom: 130%; 
            left: 50%;
            margin-left: -120px; 
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            font-size: 0.85em;
            font-weight: normal;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .info-icon-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .chart-container {
            padding: 15px;
            background-color: #2C2C2C; /* Same as stat-item */
            border-radius: 5px;
            margin-top:10px;
            height: 250px; /* Fixed height for charts */
            border: 1px solid #3A3A3A;
        }
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1E1E1E;
        }
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>AI Worker - Live Stats</h1>

        <h2>Overall Status</h2>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>
                    <span>RabbitMQ Status</span>
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">Current connection status to the RabbitMQ server and the queue this worker is listening to. Green text indicates active connection.</span>
                    </span>
                </h3>
                <p id="rabbitmq_status">N/A</p>
            </div>
            <div class="stat-item">
                <h3>
                    <span>MinIO Status</span>
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">Current connection status to the MinIO object storage server. Green text indicates active connection.</span>
                    </span>
                </h3>
                <p id="minio_status">N/A</p>
            </div>
            <div class="stat-item">
                <h3>
                    <span>Total Messages Processed</span>
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">Total number of messages (chunks) successfully processed by this worker instance since it started.</span>
                    </span>
                </h3>
                <p id="total_messages_processed">0</p>
            </div>
            <div class="stat-item">
                <h3>
                    <span>Last Message Received At</span>
                     <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">Timestamp (UTC) of the last message successfully received from RabbitMQ. Updates with each new message.</span>
                    </span>
                </h3>
                <p id="last_message_received_at">N/A</p>
            </div>
        </div>

        <h2>Graphs</h2>
        <div class="stats-grid">
            <div class="stat-item">
                <h3>RabbitMQ - Message Rates (msgs/sec)
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">A line graph showing the rate of messages being published to the queue versus the rate they are acknowledged by the worker. Helps identify bottlenecks.</span>
                    </span>
                </h3>
                <div class="chart-container">
                    <canvas id="rabbitmqChart"></canvas>
                </div>
            </div>
            <div class="stat-item">
                <h3>MinIO - Download Times (Last <span id="minio_chart_points_display">N</span> chunks)
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">A bar chart representing the time taken (in seconds) to download each of the most recent chunks from MinIO. Useful for spotting download bottlenecks.</span>
                    </span>
                </h3>
                <div class="chart-container">
                    <canvas id="minioChart"></canvas>
                </div>
            </div>
            <div class="stat-item">
                <h3>Worker - Total Processing Time (Last <span id="worker_chart_points_display">N</span> chunks)
                    <span class="info-icon-container">
                        <span class="info-icon">&#9432;</span>
                        <span class="tooltip-text">A bar chart showing the total time spent by the worker for each of the most recent chunks. This includes download, simulated AI processing, and any overhead.</span>
                    </span>
                </h3>
                <div class="chart-container">
                    <canvas id="workerChart"></canvas>
                </div>
            </div>
        </div>

        <h2>Total Chunk Processing Time with Trend (Last <span id="trend_chart_points_display">N</span> Chunks)</h2>
        <div class="stats-grid">
            <div class="stat-item" style="grid-column: 1 / -1; height: 400px;"> <!-- Span full width and increase height -->
                <h3>
                    <span>Total Processing Time (ms) with Linear Trendline
                        <span class="info-icon-container">
                            <span class="info-icon">&#9432;</span>
                            <span class="tooltip-text">A scatter plot showing the total processing time for each recent chunk, with a linear trendline to indicate performance changes over time. Time is in milliseconds.</span>
                        </span>
                    </span>
                </h3>
                <div class="chart-container" style="height: 300px;"> <!-- Adjust chart container height -->
                    <canvas id="totalProcessingTimeTrendChart"></canvas>
                </div>
            </div>
        </div>

        <h2>Recent Chunk Processing (Last <span id="max_recent_stats_display">N</span>)
            <span class="info-icon-container">
                <span class="info-icon">&#9432;</span>
                <span class="tooltip-text">A list of the latest chunks processed, showing key metrics for each. Newest entries appear at the top. The list is scrollable.</span>
            </span>
        </h2>
        <ul id="recent_chunks_list">
            <!-- Stats will be populated here -->
        </ul>
    </div>

    <script>
        let rabbitmqChartInstance, minioChartInstance, workerChartInstance, totalProcessingTimeTrendChartInstance;
        const MAX_CHART_POINTS = 20; // Max data points to show on time-series charts
        const CHART_TEXT_COLOR = '#E0E0E0'; // Light color for chart text, labels, ticks

        function initCharts() {
            const genericOptions = {
                responsive: true,
                maintainAspectRatio: false, // Important for fixed height container
                scales: {
                    x: { 
                        ticks: { autoSkip: true, maxTicksLimit: 10, color: CHART_TEXT_COLOR },
                        grid: { color: 'rgba(224, 224, 224, 0.1)' } // Lighter grid lines
                    },
                    y: { 
                        beginAtZero: true,
                        ticks: { color: CHART_TEXT_COLOR },
                        grid: { color: 'rgba(224, 224, 224, 0.1)' } // Lighter grid lines
                    }
                },
                elements: { line: { tension: 0.1 } },
                plugins: {
                    legend: { labels: { color: CHART_TEXT_COLOR } }
                }
            };

            const rabbitmqCtx = document.getElementById('rabbitmqChart').getContext('2d');
            rabbitmqChartInstance = new Chart(rabbitmqCtx, {
                type: 'line',
                data: { 
                    labels: [], 
                    datasets: [
                        { 
                            label: 'Publish Rate (msgs/sec)', 
                            data: [], 
                            borderColor: '#36A2EB', // Blue
                            backgroundColor: 'rgba(54, 162, 235, 0.2)', 
                            borderWidth: 1.5, 
                            pointBackgroundColor: '#36A2EB', 
                            pointRadius: 2  
                        },
                        { 
                            label: 'Acknowledge Rate (msgs/sec)', 
                            data: [], 
                            borderColor: '#4CAF50', // Green
                            backgroundColor: 'rgba(75, 175, 80, 0.2)', 
                            borderWidth: 1.5, 
                            pointBackgroundColor: '#4CAF50', 
                            pointRadius: 2  
                        }
                    ] 
                },
                options: {
                    ...genericOptions, // Spread generic options first
                    scales: {
                        ...genericOptions.scales, // Spread generic scales
                        y: {
                            ...genericOptions.scales.y, // Spread generic y-axis options
                            suggestedMax: 1.0 // Suggest a max of 1.0 for the y-axis
                        }
                    },
                    elements: {
                        ...genericOptions.elements,
                        line: {
                            ...genericOptions.elements.line,
                            tension: 0.1 // Increase line tension for smoother curves
                        }
                    },
                    plugins: { 
                        ...genericOptions.plugins, 
                        title: { display: false, text: 'RabbitMQ Message Rates', color: CHART_TEXT_COLOR }
                    }
                }
            });

            const minioCtx = document.getElementById('minioChart').getContext('2d');
            minioChartInstance = new Chart(minioCtx, {
                type: 'bar',
                data: { labels: [], datasets: [{ label: 'Download Duration (s)', data: [], borderColor: '#36A2EB', backgroundColor: 'rgba(54, 162, 235, 0.2)', borderWidth: 1.5 }] },
                options: {...genericOptions, plugins: { ...genericOptions.plugins, title: { display: false, text: 'MinIO Download Times', color: CHART_TEXT_COLOR }}}
            });
            document.getElementById('minio_chart_points_display').textContent = MAX_CHART_POINTS;

            const workerCtx = document.getElementById('workerChart').getContext('2d');
            workerChartInstance = new Chart(workerCtx, {
                type: 'bar',
                data: { labels: [], datasets: [{ label: 'Total Worker Time (s)', data: [], borderColor: '#4BC0C0', backgroundColor: 'rgba(75, 192, 192, 0.2)', borderWidth: 1.5 }] },
                options: {...genericOptions, plugins: { ...genericOptions.plugins, title: { display: false, text: 'Worker Processing Times', color: CHART_TEXT_COLOR }}}
            });
            document.getElementById('worker_chart_points_display').textContent = MAX_CHART_POINTS;

            const trendCtx = document.getElementById('totalProcessingTimeTrendChart').getContext('2d');
            totalProcessingTimeTrendChartInstance = new Chart(trendCtx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Total Processing Time (s)',
                            data: [],
                            backgroundColor: 'rgba(255, 99, 132, 0.6)', // Red for scatter points
                            borderColor: 'rgba(255, 99, 132, 1)',
                            pointRadius: 4,
                            pointHoverRadius: 6
                        },
                        {
                            label: 'Trendline',
                            data: [],
                            type: 'line', // This dataset will be a line
                            borderColor: '#4CAF50', // Green for trendline
                            backgroundColor: 'rgba(0,0,0,0)', // Transparent fill
                            borderWidth: 2,
                            pointRadius: 0, // No points for the trendline
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear', // Use linear scale for scatter plot
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Chunk Index', // Or time, depending on how you want to represent it
                                color: CHART_TEXT_COLOR
                            },
                            ticks: { color: CHART_TEXT_COLOR },
                            grid: { color: 'rgba(224, 224, 224, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Time (s)',
                                color: CHART_TEXT_COLOR
                            },
                            ticks: { color: CHART_TEXT_COLOR },
                            grid: { color: 'rgba(224, 224, 224, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: CHART_TEXT_COLOR } },
                        title: { display: false, text: 'Total Processing Time Trend', color: CHART_TEXT_COLOR }
                    },
                    // Tooltip for scatter plot to show x (index) and y (time)
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.dataset.type === 'scatter') {
                                    label += `(Chunk ${context.parsed.x}, ${context.parsed.y.toFixed(2)}s)`;
                                } else {
                                    label += `${context.parsed.y.toFixed(2)}s`;
                                }
                                return label;
                            }
                        }
                    }
                }
            });
            document.getElementById('trend_chart_points_display').textContent = MAX_CHART_POINTS;
        }

        let timestamps = []; // For RabbitMQ chart x-axis - can be used if needed for more precise time

        function updateCharts(statsData) {
            const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // RabbitMQ Chart (Publish vs Acknowledge Rates)
            if (rabbitmqChartInstance) {
                rabbitmqChartInstance.data.labels.push(now);
                rabbitmqChartInstance.data.datasets[0].data.push(statsData.rabbitmq_publish_rate || 0); // Publish Rate
                rabbitmqChartInstance.data.datasets[1].data.push(statsData.rabbitmq_ack_rate || 0);   // Acknowledge Rate
                
                if (rabbitmqChartInstance.data.labels.length > MAX_CHART_POINTS) {
                    rabbitmqChartInstance.data.labels.shift();
                    rabbitmqChartInstance.data.datasets[0].data.shift();
                    rabbitmqChartInstance.data.datasets[1].data.shift();
                }
                rabbitmqChartInstance.update('none'); // 'none' for no animation, smoother updates
            }

            // MinIO Chart & Worker Chart (from recent_chunk_stats)
            if (minioChartInstance && workerChartInstance && statsData.recent_chunk_stats) {
                const recentChunks = statsData.recent_chunk_stats.slice(-MAX_CHART_POINTS); 
                
                // Shorten labels for charts, using timestamp as a simple unique ID for the x-axis
                const chartLabels = recentChunks.map(chunk => new Date(chunk.received_at * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                
                const minioDownloadData = recentChunks.map(chunk => chunk.download_duration_ms / 1000); // Convert ms to seconds
                minioChartInstance.data.labels = chartLabels;
                minioChartInstance.data.datasets[0].data = minioDownloadData;
                minioChartInstance.options.scales.y.title.text = 'Download Duration (s)'; // Update Y-axis title
                minioChartInstance.update('none');

                const workerTotalTimeData = recentChunks.map(chunk => chunk.total_worker_time_ms / 1000); // Convert ms to seconds
                workerChartInstance.data.labels = chartLabels; 
                workerChartInstance.data.datasets[0].data = workerTotalTimeData;
                workerChartInstance.options.scales.y.title.text = 'Total Worker Time (s)'; // Update Y-axis title
                workerChartInstance.update('none');
            }

            // Total Processing Time Trend Chart
            if (totalProcessingTimeTrendChartInstance && statsData.recent_chunk_stats) {
                const recentChunks = statsData.recent_chunk_stats;
                const totalWorkerTimesInSeconds = recentChunks.map(chunk => chunk.total_worker_time_ms / 1000);
                
                const scatterData = totalWorkerTimesInSeconds.map((time, index) => ({ x: index, y: time }));
                totalProcessingTimeTrendChartInstance.data.datasets[0].data = scatterData;

                // Generate trendline data based on the returned slope and intercept
                const slope = statsData.total_processing_time_trend.slope / 1000; // Slope is in ms, convert to seconds
                const intercept = statsData.total_processing_time_trend.intercept / 1000; // Intercept is in ms, convert to seconds

                if (recentChunks.length > 1) {
                    const trendlineData = [];
                    // Calculate start and end points for the trendline
                    const minX = 0;
                    const maxX = recentChunks.length - 1;

                    trendlineData.push({ x: minX, y: slope * minX + intercept });
                    trendlineData.push({ x: maxX, y: slope * maxX + intercept });

                    totalProcessingTimeTrendChartInstance.data.datasets[1].data = trendlineData;
                } else {
                    totalProcessingTimeTrendChartInstance.data.datasets[1].data = []; // Clear trendline if not enough data
                }
                totalProcessingTimeTrendChartInstance.update('none');
            }
        }

        function fetchStats() {
            fetch('/stats')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    document.getElementById('rabbitmq_status').textContent = data.rabbitmq_status || 'N/A';
                    document.getElementById('minio_status').textContent = data.minio_status || 'N/A';
                    
                    // Style status based on content
                    if(data.rabbitmq_status && data.rabbitmq_status.toLowerCase().includes("connected")){
                        document.getElementById('rabbitmq_status').style.color = '#4CAF50'; // Green for connected
                    } else {
                        document.getElementById('rabbitmq_status').style.color = '#FFB300'; // Amber for other states
                    }
                    if(data.minio_status && data.minio_status.toLowerCase().includes("connected")){
                        document.getElementById('minio_status').style.color = '#4CAF50';
                    } else {
                        document.getElementById('minio_status').style.color = '#FFB300';
                    }

                    document.getElementById('total_messages_processed').textContent = data.total_messages_processed || 0;
                    document.getElementById('last_message_received_at').textContent = data.last_message_received_at ? new Date(data.last_message_received_at).toLocaleString() : 'N/A';
                    
                    const statsList = document.getElementById('recent_chunks_list');
                    statsList.innerHTML = ''; 

                    if (data.recent_chunk_stats && data.recent_chunk_stats.length > 0) {
                        const numToDisplayInList = data.recent_chunk_stats.length;
                        document.getElementById('max_recent_stats_display').textContent = numToDisplayInList > MAX_CHART_POINTS ? `${MAX_CHART_POINTS} (showing ${numToDisplayInList} in list)` : numToDisplayInList;
                        
                        const displayChunks = data.recent_chunk_stats.slice(-(data.max_recent_stats || 50)); // Show up to 50 in list
                        displayChunks.reverse().forEach(chunk => {
                            const listItem = document.createElement('li');
                            const chunkName = chunk.chunk_url.split('/').pop();
                            let aiResultDisplay = '';
                            if (chunk.ai_simulation_result) {
                                const resultColor = chunk.ai_simulation_result === 'violence' ? '#F44336' : '#4CAF50'; // Red for violence, Green for no_violence
                                aiResultDisplay = `<br><strong>AI Result:</strong> <span style="color: ${resultColor};">${chunk.ai_simulation_result}</span>`;
                            }

                            listItem.innerHTML = `
                                <strong>Chunk:</strong> <span title="${chunk.chunk_url}">${chunkName}</span> <br>
                                <small>
                                <strong>Received:</strong> ${new Date(chunk.received_at * 1000).toLocaleString()} | 
                                <strong>Download:</strong> ${(chunk.download_duration_ms / 1000).toFixed(2)}s | 
                                <strong>AI Proc:</strong> ${(chunk.ai_processing_time_ms / 1000).toFixed(2)}s | 
                                <strong>Total Worker:</strong> ${(chunk.total_worker_time_ms / 1000).toFixed(2)}s
                                ${aiResultDisplay}
                                </small>
                            `;
                            statsList.appendChild(listItem);
                        });
                    } else {
                        document.getElementById('max_recent_stats_display').textContent = '0';
                        statsList.innerHTML = '<li>No recent chunk data.</li>';
                    }

                    updateCharts(data);
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    const statusElements = ['rabbitmq_status', 'minio_status', 'total_messages_processed', 'last_message_received_at'];
                    statusElements.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.textContent = 'Error loading stats';
                        if (el) el.style.color = '#F44336'; // Red for error
                    });
                });
        }

        window.onload = () => {
            initCharts();
            fetchStats(); 
            setInterval(fetchStats, 5000);
        };
    </script>
</body>
</html>